//-------------------------------------------------------------------------------------
// forEach()
// - for문을 대체하는 고차함수
// - 반복문을 추상화하여 구현된 메서드로 내부에서 주어진 배열을 순회하면서 연산을 수행
// - for문과 다르게 중간에서 break할 수 없음

// 배열 요소의 총합 구하기
const numArr = [1, 2, 3, 4, 5];
let total = 0;

numArr.forEach((item)=>{
    total += item;
});

console.log(total); // 15

//-------------------------------------------------------------------------------------
// map()
// - 배열을 순회하면서 콜백함수에서의 실행결과를 반환한 값으로 이루어진 배열을 반환

// 배열의 요소가 짝수이면 'even', 홀수이면 'odd'인 새로운 배열 반환하기
const numArr2 = [1, 2, 3, 4, 5];
const numMapArr = numArr2.map((item) => {
    return (item % 2 == 0) ? 'even' : 'odd';
})

console.log(numMapArr); // ['odd', 'even', 'odd', 'even', 'odd']

// * forEach와 map의 차이 : 두 메서드 모두 배열을 순회하는 것은 동일하지만
//   forEach()는 각 요소를 참조한 연산이 이루어지고 map()은 각 요소를 다른 값으로 맵핑한 새로운 배열이 반환됨

//-------------------------------------------------------------------------------------
// find()
// - 주어진 배열을 순회하면서 콜백함수 실행의 반환값이 true에 해당하는 첫 번째 요소를 반환

const numberArr2 = [1, 3, 3, 5, 7];
const objectArr = [
    { name: 'apple', age: 20 },
    { name: 'orange', age: 30 },
    { name: 'banana', age: 40 }
];
 
console.log(objectArr.find(item => {
   return item.age === 20 // 해당조건에 부합하면 item값 반환
}));

console.log(numberArr.find(item => item === 3));  // 3

//-------------------------------------------------------------------------------------
// findIndex()
// - 결과가 참인 첫번째 요소의 인덱스를 반환
// - 참인 요소가 존재하지 않을 경우 -1 반환

// 나이가 20인 사람 찾기
const objectArr2 = [
    { name: 'apple', age: 20 },
    { name: 'orange', age: 30 },
    { name: 'banana', age: 40 }
];

console.log(objectArr2.findIndex(item => {return item.age === 20})); // 0
// 해당조건에 부합하면 item의 인덱스를 반환
  
 console.log(objectArr2.findIndex(item => item.name === 'apple')); // 1

//-------------------------------------------------------------------------------------
// filter()
// - 주어진 배열을 순회하면서 콜백함수의 반환값이 true에 해당하는 요소로만 구성된 새로운 배열을 생성하여 반환

// 짝수인 것만 배열로 반환하기
const numberArr = [1, 2, 3, 4, 5];

const numberFilterArr = numberArr.filter((item) => {
    return item % 2 === 0; // 해당조건에 부합으면 item을 넣어 배열 반환
});

console.log(numberFilterArr); // [2, 4]

//-------------------------------------------------------------------------------------
// sort()
// - 콜백함수를 통해 특정한 기준에 따라 원 배열이 정렬됨

// 배열 오름차순으로 정렬하기
const arr = [2, 1, 3, 10];

arr.sort(function(a, b)  {
  return a - b;
});  // [1, 2, 3, 10] 오름차순

// 배열 내림차순으로 정렬하기
arr.sort(function(a, b)  {
  return b - a;
}); // [10, 3, 2, 1] 내림차순

//-------------------------------------------------------------------------------------
// splice
// - 해당 구간 인덱스의 요소를 다른 요소로 바꾸거나 삭제하고 새로운 배열을 반환

// a 배열 중에 [1,2]만 출력하기
const a = [1,2,3,4,5];
const b = a.splice(0,2);
 
console.log(b); // 출력: [1,2]

//-------------------------------------------------------------------------------------
// slice
// - 해당 구간 인덱스만을 가지는 새로운 배열을 반환

// c 배열 중에 [2,3]만 출력하기
const c = [1,2,3,4,5];  
const d = c.slice(1,3);

console.log(d); // 출력: [2,3]

//-------------------------------------------------------------------------------------
// shift
// - 배열의 첫번째 요소를 제거

// e 배열의 첫번째 요소 제거하기
const e = [1,2,3,4,5];

e.shift(); 
console.log(e); // 출력: [2,3,4,5]

//-------------------------------------------------------------------------------------
// pop
// - 배열의 마지막 요소를 제거

const f = [1,2,3,4,5];

f.pop();
console.log(f); // 출력: [1,2,3,4]

//-------------------------------------------------------------------------------------
// concat
// - 배열 끝에 새로운 요소 추가

g.concat(value);

const g = [1, 2, 3];
const newG = arr2.concat(4, 5, 6);
const newF = arr2.concat([4, [5, 6]]); 

//-------------------------------------------------------------------------------------
// join
// - 배열 요소를 문자열로 병합

const h = [1, 2, 3];
const str = h.join("-"); // "1-2-3"





